package levels.ldtk;

import ldtk.Entity;
import entities.interact.BallLock;
import entities.interact.SumTrigger;
import entities.interact.MessageEntity;
import flixel.math.FlxMath;
import echo.util.ext.FloatExt.deg_to_rad;
import entities.interact.LightShow;
import entities.interact.LightArrow;
import entities.interact.LightTallTriangle;
import entities.interact.LightShortTriangle;
import entities.interact.LightSquare;
import entities.interact.LightLargeRound;
import entities.interact.Sensor;
import entities.interact.Gate;
import entities.interact.DropTarget;
import entities.interact.LightSmallRound;
import entities.interact.PopperSmall;
import nape.geom.Vec2;
import entities.interact.TargetLarge;
import entities.interact.TargetSmall;
import entities.interact.CollectionTrigger;
import entities.interact.Interactable;
import openfl.utils.AssetType;
import openfl.Assets;
import flixel.FlxObject;
import entities.interact.Tunnel;
import entities.interact.Kicker;
import types.Direction;
import entities.interact.Slingshot;
import entities.interact.Popper;
import entities.Flipper;
import flixel.FlxSprite;
import entities.CameraTransition;
import flixel.math.FlxRect;
import flixel.math.FlxPoint;
import levels.ldtk.Ldtk.LdtkProject;

using levels.ldtk.LdtkUtils;

/**
 * The middle layer between LDTK project and game code. This class
 * should do all of the major parsing of project data into flixel
 * types and basic game objects.
**/
class Level {
	public static var project = new LdtkProject();

	/**
	 * World id that this level was loaded from
	**/
	public var worldID:String;

	public var world:Ldtk.Ldtk_World;

	/**
	 * The raw level from the project. Available to get any needed
	 * one-off values out of the level for special use-cases
	**/
	public var rawLevels:Array<Ldtk.Ldtk_Level> = [];

	public var levelBgs:Array<FlxSprite> = [];
	public var levelFgs:Array<FlxSprite> = [];
	public var levelTops:Array<FlxSprite> = [];

	// This is the painted image for the level itself
	public var terrainRender:Array<FlxSprite> = [];

	public var terrainLayers:Array<BDTilemap> = [];
	public var spawnPoint:FlxPoint = FlxPoint.get();

	public var camZones = new Map<String, FlxRect>();
	public var focusZones = new Array<FlxObject>();
	public var camTransitions = new Array<CameraTransition>();

	public var flippers:Array<Flipper> = [];
	public var poppers:Array<Popper> = [];
	public var poppersSmall:Array<PopperSmall> = [];
	public var slingshots:Array<Slingshot> = [];

	var allEnts:Array<Entity> = [];
	var allObjs:Array<FlxObject> = [];

	public var ballLocks:Array<BallLock> = [];

	public var kickers:Array<Kicker> = [];
	public var tunnels:Array<Tunnel> = [];
	public var interactables:Array<Interactable> = [];
	public var triggerables:Array<Triggerable> = [];
	public var lightShows:Array<LightShow> = [];
	public var summers:Array<SumTrigger> = [];

	public function new(worldNameOrIID:String, nameOrIID:String) {
		this.worldID = worldNameOrIID;
		for (w in project.worlds) {
			if (w.identifier == worldNameOrIID || w.iid == worldNameOrIID) {
				world = w;
			}
		}
		if (world == null) {
			// TODO: how to handle?
			throw('no world with name/IID: $worldNameOrIID');
		}

		// We are loading each world as a full "level" in terms of gameplay.
		// So we load every level in the world file and stitch them all together
		for (raw in world.levels) {
			rawLevels.push(raw);

			// TODO: Make sure these match the paths generated by the aseprite files, once they exist
			var bgPath = 'assets/aseprite/backgrounds/${world.identifier}_${raw.identifier}_bg.png';
			var fgPath = 'assets/aseprite/backgrounds/${world.identifier}_${raw.identifier}_fg.png';
			if (Assets.exists(bgPath, AssetType.IMAGE)) {
				var bgSprite = new FlxSprite(raw.worldX, raw.worldY, bgPath);
				levelBgs.push(bgSprite);
			} else {
				trace('not found: $bgPath');
			}
			if (Assets.exists(fgPath, AssetType.IMAGE)) {
				var fgSprite = new FlxSprite(raw.worldX, raw.worldY, fgPath);
				levelFgs.push(fgSprite);
			} else {
				trace('not found: $fgPath');
			}

			var autoTileLayer = new BDTilemap();
			autoTileLayer.loadLdtk(raw.l_AutoLayer_baked);
			autoTileLayer.setPosition(raw.worldX, raw.worldY);
			terrainLayers.push(autoTileLayer);

			var terrainLayer = new BDTilemap();
			terrainLayer.loadLdtk(raw.l_Terrain);
			terrainLayer.setPosition(raw.worldX, raw.worldY);
			terrainLayers.push(terrainLayer);

			if (raw.l_Objects.all_Spawn.length > 0) {
				var sp = raw.l_Objects.all_Spawn[0];
				spawnPoint.set(sp.worldPixelX, sp.worldPixelY);
			}

			parseCameraZones(raw.l_Objects.all_CameraZone);
			parseCameraTransitions(raw.l_Objects.all_CameraTransition);
			parseFlippers(raw.l_Objects.all_FlipperLeft, raw.l_Objects.all_FlipperRight, raw.l_Objects.all_FlipperFree);
			parsePoppers(raw.l_Objects.all_Popper, raw.l_Objects.all_SmallPopper);
			parseSlingshots(raw.l_Objects.all_Slingshot_Left, raw.l_Objects.all_Slingshot_Right);
			parseTunnels(raw.l_Objects.all_Tunnel);
			parseTriggerables(raw.l_Objects.all_CollectionTrigger, raw.l_Objects.all_TargetSmall, raw.l_Objects.all_TargetLarge, raw.l_Objects.all_DropTarget,
				raw.l_Objects.all_LightSmallRound, raw.l_Objects.all_LightLargeRound, raw.l_Objects.all_LightSquare, raw.l_Objects.all_LightArrow,
				raw.l_Objects.all_LightShortTriangle, raw.l_Objects.all_LightTallTriangle, raw.l_Objects.all_LightShow, raw.l_Objects.all_Post,
				raw.l_Objects.all_Gate, raw.l_Objects.all_Sensor, raw.l_Objects.all_Message, raw.l_Objects.all_SumTrigger);
			parseKickers(raw.l_Objects.all_Kicker);
			parseBallLocks(raw.l_Objects.all_BallLock);

			for (o in raw.l_Objects.getAllUntyped()) {
				allEnts.push(o);
			}
		}

		matchBallLocks();
		matchTunnels();
	}

	function matchBallLocks() {
		for (bl in ballLocks) {
			for (dest in allEnts) {
				if (bl.destIID == dest.iid) {
					bl.exit.set(dest.worldPixelX, dest.worldPixelY);
				}
			}

			for (p in poppersSmall) {
				if (bl.aliveIIDs.contains(p.IID)) {
					bl.aliveOnActivate.push(p);
				}
				if (bl.killIIDs.contains(p.IID)) {
					bl.killOnActivate.push(p);
				}
			}

			for (p in kickers) {
				if (bl.aliveIIDs.contains(p.IID)) {
					bl.aliveOnActivate.push(p);
				}
				if (bl.killIIDs.contains(p.IID)) {
					bl.killOnActivate.push(p);
				}
			}

			bl.prekill();
		}
	}

	function matchTunnels() {
		for (t in tunnels) {
			for (e in tunnels) {
				if (t.exitIID == e.IID) {
					t.exit = e;
				}
			}
		}
	}

	function parseCameraZones(zoneDefs:Array<Ldtk.Entity_CameraZone>) {
		for (z in zoneDefs) {
			if (z.f_AutoFocus) {
				focusZones.push(new FlxObject(z.worldPixelX, z.worldPixelY, z.width, z.height));
			} else {
				camZones.set(z.iid, FlxRect.get(z.worldPixelX, z.worldPixelY, z.width, z.height));
			}
		}
	}

	function parseCameraTransitions(areaDefs:Array<Ldtk.Entity_CameraTransition>) {
		camTransitions = new Array<CameraTransition>();
		for (def in areaDefs) {
			var transArea = FlxRect.get(def.worldPixelX, def.worldPixelY, def.width, def.height);
			var camTrigger = new CameraTransition(transArea);
			for (i in 0...def.f_Directions.length) {
				camTrigger.addGuideTrigger(def.f_Directions[i], camZones.get(def.f_Zones[i].entityIid));
			}
			camTransitions.push(camTrigger);
		}
	}

	function parseFlippers(leftDefs:Array<Ldtk.Entity_FlipperLeft>, rightDefs:Array<Ldtk.Entity_FlipperRight>, freeDefs:Array<Ldtk.Entity_FlipperFree>) {
		for (ld in leftDefs) {
			var f = new Flipper(LEFT, ld.worldPixelX, ld.worldPixelY, 80, 13, 8, deg_to_rad(30), deg_to_rad(30 - ld.f_Travel), ld.f_Mass);
			flippers.push(f);
		}
		for (rd in rightDefs) {
			var f = new Flipper(RIGHT, rd.worldPixelX, rd.worldPixelY, 80, 13, 8, deg_to_rad(150), deg_to_rad(150 + rd.f_Travel), rd.f_Mass);
			flippers.push(f);
		}
		for (fd in freeDefs) {
			var restAng = rotateTo(Vec2.get(fd.cx, fd.cy), Vec2.get(fd.f_Rest.cx, fd.f_Rest.cy));
			var activeAng = rotateTo(Vec2.get(fd.cx, fd.cy), Vec2.get(fd.f_Active.cx, fd.f_Active.cy));

			while (fd.f_Clockwise && activeAng < restAng) {
				activeAng += Math.PI * 2;
			}

			while (!fd.f_Clockwise && activeAng > restAng) {
				activeAng -= Math.PI * 2;
			}
			flippers.push(new Flipper(fd.f_Clockwise ? RIGHT : LEFT, fd.worldPixelX, fd.worldPixelY, 80, 13, 8, restAng, activeAng, fd.f_Mass));
		}
	}

	function parsePoppers(popperDefs:Array<Ldtk.Entity_Popper>, smallPopDefs:Array<Ldtk.Entity_SmallPopper>) {
		for (pd in popperDefs) {
			var p = new Popper(pd.worldPixelX, pd.worldPixelY, 75);
			p.IID = pd.iid;
			poppers.push(p);
		}
		for (pd in smallPopDefs) {
			var p = new PopperSmall(pd.worldPixelX, pd.worldPixelY, 75);
			p.IID = pd.iid;
			poppersSmall.push(p);
		}
	}

	function parseSlingshots(leftDefs:Array<Ldtk.Entity_Slingshot_Left>, rightDefs:Array<Ldtk.Entity_Slingshot_Right>) {
		for (ld in leftDefs) {
			slingshots.push(new Slingshot(ld.worldPixelX, ld.worldPixelY, 750, Direction.RIGHT, 0));
		}

		for (rd in rightDefs) {
			slingshots.push(new Slingshot(rd.worldPixelX, rd.worldPixelY, 750, Direction.LEFT, 0));
		}
	}

	function parseTunnels(tunnelDefs:Array<Ldtk.Entity_Tunnel>) {
		for (td in tunnelDefs) {
			var tunnel = new Tunnel(td.worldPixelX, td.worldPixelY);
			tunnel.IID = td.iid;
			if (td.f_Exit != null) {
				tunnel.exitIID = td.f_Exit.entityIid;
			}
			tunnels.push(tunnel);
		}

		for (td in tunnelDefs) {
			if (td.f_Exit == null) {
				continue;
			}

			var entrance:Tunnel = null;
			var exit:Tunnel = null;
			for (tun in tunnels) {
				if (tun.IID == td.iid) {
					entrance = tun;
				}

				if (tun.IID == td.f_Exit.entityIid) {
					exit = tun;
					tun.setExit();
				}

				if (entrance != null && exit != null) {
					break;
				}
			}

			if (entrance != null && exit != null) {
				entrance.exit = exit;
			}
		}
	}

	function parseBallLocks(blDefs:Array<Ldtk.Entity_BallLock>) {
		for (d in blDefs) {
			var block = new BallLock(d.worldPixelX, d.worldPixelY, d.f_Destination.entityIid);
			for (a in d.f_ToAlive) {
				block.aliveIIDs.push(a.entityIid);
			}
			for (k in d.f_ToKill) {
				block.killIIDs.push(k.entityIid);
			}
			ballLocks.push(block);
		}
	}

	function parseKickers(kDefs:Array<Ldtk.Entity_Kicker>) {
		for (kickerDef in kDefs) {
			var dir = 0.0;
			if (kickerDef.f_Direction != null) {
				dir = rotateTo(Vec2.get(kickerDef.cx, kickerDef.cy), Vec2.get(kickerDef.f_Direction.cx, kickerDef.f_Direction.cy));
			}
			var k = new Kicker(kickerDef.worldPixelX, kickerDef.worldPixelY, dir, kickerDef.f_Force);
			k.IID = kickerDef.iid;
			kickers.push(k);
		}
	}

	function parseTriggerables(collectionTriggers:Array<Ldtk.Entity_CollectionTrigger>, smallTargets:Array<Ldtk.Entity_TargetSmall>,
			largeTargets:Array<Ldtk.Entity_TargetLarge>, dropTargets:Array<Ldtk.Entity_DropTarget>, smallRoundLights:Array<Ldtk.Entity_LightSmallRound>,
			largeRoundLights:Array<Ldtk.Entity_LightLargeRound>, squareLights:Array<Ldtk.Entity_LightSquare>, arrowLights:Array<Ldtk.Entity_LightArrow>,
			shortTriangleLights:Array<Ldtk.Entity_LightShortTriangle>, tallTriangleLights:Array<Ldtk.Entity_LightTallTriangle>,
			lightShows:Array<Ldtk.Entity_LightShow>, posts:Array<Ldtk.Entity_Post>, gates:Array<Ldtk.Entity_Gate>, sensors:Array<Ldtk.Entity_Sensor>,
			messages:Array<Ldtk.Entity_Message>, sumTriggers:Array<Ldtk.Entity_SumTrigger>) {
		var listenerToNode = new Map<Triggerable, String>();
		for (v in smallTargets) {
			var rotation = 0.0;
			if (v.f_RotateTo != null) {
				rotation = rotateTo(Vec2.get(v.cx, v.cy), Vec2.get(v.f_RotateTo.cx, v.f_RotateTo.cy)) + Math.PI * 1.5;
			}
			var t = new TargetSmall(v.worldPixelX, v.worldPixelY, rotation);
			t.IID = v.iid;
			interactables.push(t);
			triggerables.push(t);
		}
		for (v in largeTargets) {
			var rotation = 0.0;
			if (v.f_RotateTo != null) {
				rotation = rotateTo(Vec2.get(v.cx, v.cy), Vec2.get(v.f_RotateTo.cx, v.f_RotateTo.cy)) + Math.PI * 1.5;
			}
			var t = new TargetLarge(v.worldPixelX, v.worldPixelY, rotation);
			t.IID = v.iid;
			interactables.push(t);
			triggerables.push(t);
		}
		for (v in smallRoundLights) {
			var t = new LightSmallRound(v.worldPixelX, v.worldPixelY);
			t.IID = v.iid;
			t.followListensTo = v.f_FollowListensTo;
			if (v.f_ListensTo != null) {
				listenerToNode.set(t, v.f_ListensTo.entityIid);
			}
			interactables.push(t); // should this actually be interactable?
			triggerables.push(t);
		}
		for (v in largeRoundLights) {
			var t = new LightLargeRound(v.worldPixelX, v.worldPixelY);
			t.IID = v.iid;
			t.followListensTo = v.f_FollowListensTo;
			if (v.f_ListensTo != null) {
				listenerToNode.set(t, v.f_ListensTo.entityIid);
			}
			interactables.push(t); // should this actually be interactable?
			triggerables.push(t);
		}
		for (v in squareLights) {
			var t = new LightSquare(v.worldPixelX, v.worldPixelY);
			t.IID = v.iid;
			t.followListensTo = v.f_FollowListensTo;
			if (v.f_ListensTo != null) {
				listenerToNode.set(t, v.f_ListensTo.entityIid);
			}
			interactables.push(t); // should this actually be interactable?
			triggerables.push(t);
		}
		for (v in shortTriangleLights) {
			var rotation = 0.0;
			if (v.f_RotateTo != null) {
				rotation = rotateTo(Vec2.get(v.cx, v.cy), Vec2.get(v.f_RotateTo.cx, v.f_RotateTo.cy)) + Math.PI * 0.5;
			}
			var t = new LightShortTriangle(v.worldPixelX, v.worldPixelY, rotation);
			t.IID = v.iid;
			t.followListensTo = v.f_FollowListensTo;
			if (v.f_ListensTo != null) {
				listenerToNode.set(t, v.f_ListensTo.entityIid);
			}
			interactables.push(t); // should this actually be interactable?
			triggerables.push(t);
		}
		for (v in tallTriangleLights) {
			var rotation = 0.0;
			if (v.f_RotateTo != null) {
				rotation = rotateTo(Vec2.get(v.cx, v.cy), Vec2.get(v.f_RotateTo.cx, v.f_RotateTo.cy)) + Math.PI * 0.5;
			}
			var t = new LightTallTriangle(v.worldPixelX, v.worldPixelY, rotation);
			t.IID = v.iid;
			t.followListensTo = v.f_FollowListensTo;
			if (v.f_ListensTo != null) {
				listenerToNode.set(t, v.f_ListensTo.entityIid);
			}
			interactables.push(t); // should this actually be interactable?
			triggerables.push(t);
		}
		for (v in arrowLights) {
			var rotation = 0.0;
			if (v.f_RotateTo != null) {
				rotation = rotateTo(Vec2.get(v.cx, v.cy), Vec2.get(v.f_RotateTo.cx, v.f_RotateTo.cy)) + Math.PI * 0.5;
			}
			var t = new LightArrow(v.worldPixelX, v.worldPixelY, rotation);
			t.IID = v.iid;
			if (v.f_ListensTo != null) {
				listenerToNode.set(t, v.f_ListensTo.entityIid);
			}
			interactables.push(t); // should this actually be interactable?
			triggerables.push(t);
		}
		var lightShowToNodes = new Map<LightShow, Array<String>>();
		var lightShowToListens = new Map<LightShow, String>();
		for (v in lightShows) {
			var t = new LightShow();
			t.IID = v.iid;
			t.showType = v.f_ShowType;
			t.numOfCycles = v.f_NumOfCycles;
			t.stepSpeed = v.f_StepSpeed;
			if (v.f_ListensTo != null) {
				lightShowToListens.set(t, v.f_ListensTo.entityIid);
			}
			if (v.f_Nodes != null && v.f_Nodes.length > 0) {
				lightShowToNodes.set(t, v.f_Nodes.map((f) -> f.entityIid));
			}
		}

		for (v in dropTargets) {
			var rotation = 0.0;
			if (v.f_RotateTo != null) {
				rotation = rotateTo(Vec2.get(v.cx, v.cy), Vec2.get(v.f_RotateTo.cx, v.f_RotateTo.cy)) + Math.PI * 1.5;
			}
			var t = new DropTarget(v.worldPixelX, v.worldPixelY, rotation);
			t.IID = v.iid;
			t.secondsToReset = v.f_SecondsToReset;
			if (v.f_ListensTo != null) {
				listenerToNode.set(t, v.f_ListensTo.entityIid);
			}
			interactables.push(t);
			triggerables.push(t);
		}
		for (v in gates) {
			var rotation = 0.0;
			if (v.f_RotateTo != null) {
				rotation = rotateTo(Vec2.get(v.cx, v.cy), Vec2.get(v.f_RotateTo.cx, v.f_RotateTo.cy)) + Math.PI * 1.5;
			}
			var t = new Gate(v.worldPixelX, v.worldPixelY, rotation);
			t.IID = v.iid;
			if (v.f_ListensTo != null) {
				listenerToNode.set(t, v.f_ListensTo.entityIid);
			}
			interactables.push(t);
			triggerables.push(t);
		}
		for (v in sensors) {
			var t = new Sensor(v.worldPixelX, v.worldPixelY, v.width, v.height);
			t.IID = v.iid;
			t.secondsToReset = v.f_SecondsToReset;
			if (v.f_ListensTo != null) {
				listenerToNode.set(t, v.f_ListensTo.entityIid);
			}
			interactables.push(t);
			triggerables.push(t);
		}
		for (v in messages) {
			var t = new MessageEntity();
			t.IID = v.iid;
			t.content = v.f_Content;
			t.secondsUntilHidden = v.f_SecondsUntilHide;
			if (v.f_ListensTo != null) {
				listenerToNode.set(t, v.f_ListensTo.entityIid);
			}
			triggerables.push(t);
		}
		var sumTriggerToNodes = new Map<SumTrigger, Array<String>>();
		for (v in sumTriggers) {
			var nodeIds = v.f_Nodes.map((f) -> f.entityIid);
			var t = new SumTrigger();
			t.IID = v.iid;
			t.requiredSum = v.f_RequiredSum;
			t.shouldDisableNodesOnComplete = v.f_DisableNodes;
			t.shouldResetNodesOnComplete = v.f_ResetNodes;
			summers.push(t);
			triggerables.push(t);
			sumTriggerToNodes.set(t, nodeIds);
		}
		var triggerToNodes = new Map<CollectionTrigger, Array<String>>();
		for (v in collectionTriggers) {
			var nodeIds = v.f_Nodes.map((f) -> f.entityIid);
			var t = new CollectionTrigger();
			t.IID = v.iid;
			t.onlyOneNodeRequired = v.f_OR;
			t.shouldDisableNodesOnComplete = v.f_DisableNodes;
			t.shouldResetNodesOnComplete = v.f_ResetNodes;
			t.sfx = v.f_SFX;
			t.maxTriggers = v.f_MaxTriggers;
			triggerables.push(t);
			triggerToNodes.set(t, nodeIds);
		}

		// loop through trigger entity references to map them onto each other now that they are all parsed
		for (t in triggerToNodes.keys()) {
			var nodeIds = triggerToNodes.get(t);
			for (nodeId in nodeIds) {
				for (triggerable in triggerables) {
					if (triggerable.IID == nodeId) {
						t.add(triggerable);
					}
				}
			}
		}
		for (t in sumTriggerToNodes.keys()) {
			var nodeIds = sumTriggerToNodes.get(t);
			for (nodeId in nodeIds) {
				for (interactable in interactables) {
					if (interactable.IID == nodeId) {
						t.nodes.push(interactable);
					}
				}
				for (triggerable in triggerables) {
					if (triggerable.IID == nodeId) {
						t.otherNodes.push(triggerable);
					}
				}
			}
		}
		for (t in listenerToNode.keys()) {
			var nodeId = listenerToNode.get(t);
			for (triggerable in triggerables) {
				if (triggerable.IID == nodeId) {
					triggerable.onOffSignal.add((isOn) -> {
						if (isOn) {
							trace('turn on: ${t.IID}');
							t.setOn(true);
						} else if (t.followListensTo) {
							t.setOn(false);
						}
					});
				}
			}
		}
		for (ls in lightShowToNodes.keys()) {
			var nodeIds = lightShowToNodes.get(ls);
			for (nodeId in nodeIds) {
				for (triggerable in triggerables) {
					if (triggerable.IID == nodeId) {
						ls.nodes.push(cast triggerable);
					}
				}
			}
		}
		for (ls in lightShowToListens.keys()) {
			var nodeId = lightShowToListens.get(ls);
			for (triggerable in triggerables) {
				if (triggerable.IID == nodeId) {
					triggerable.onOffSignal.add(ls.start);
				}
			}
		}
	}

	function rotateTo(pos:Vec2, rotateTo:Vec2) {
		var rel = Vec2.get(rotateTo.x - pos.x, rotateTo.y - pos.y);
		rel = rel.normalise();
		return rel.angle;
	}
}
